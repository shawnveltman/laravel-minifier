<?php

// config for Shawnveltman/LaravelMinifier
return [
    'path' => env('MINIFIER_PATH', 'ai_rag/classes.txt'),
    'disk' => env('MINIFIER_DISK', 'local'),
    'namespaces' => [
        'App',
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
        // Add additional namespaces as needed...
    ],
];
<?php

namespace Shawnveltman\LaravelMinifier\CodeParser;

use Illuminate\Support\Facades\Storage;
use ReflectionClass;
use ReflectionMethod;

class ClassContentService
{
    public function createClassFiles(array $requiredClassesAndMethods): void
    {
        $classContents = [];

        foreach ($requiredClassesAndMethods as $className => $methods) {
            $reflection = new ReflectionClass($className);
            $fileContent = file_get_contents($reflection->getFileName());
            $namespace = $reflection->getNamespaceName();
            $useStatements = $this->extractUseStatements($fileContent);
            $shortName = $reflection->getShortName();

            // Construct the class definition with inheritance and interfaces
            $classDefinition = "class {$shortName}";
            if ($parentClass = $reflection->getParentClass()) {
                $classDefinition .= ' extends '.$parentClass->getShortName();
            }
            $interfaces = $reflection->getInterfaceNames();
            if (! empty($interfaces)) {
                $interfaceShortNames = array_map(static function ($interface) {
                    return (new ReflectionClass($interface))->getShortName();
                }, $interfaces);
                $classDefinition .= ' implements '.implode(', ', $interfaceShortNames);
            }

            // Add namespace, use statements, and class definition
            $newClassContent = "<?php\n\nnamespace {$namespace};\n\n{$useStatements}\n\n{$classDefinition}\n{";

            // Add each required method
            foreach ($methods as $methodName) {
                $methodReflection = new ReflectionMethod($className, $methodName);
                $traitReflection = $this->getTraitMethodReflection($methodReflection);

                if ($traitReflection) {
                    $startLine = $traitReflection->getStartLine() - 1;
                    $fileContent = file_get_contents($traitReflection->getDeclaringClass()->getFileName());
                } else {
                    $startLine = $methodReflection->getStartLine() - 1;
                }
                $lines = explode("\n", $fileContent);

                $endLine = $methodReflection->getEndLine();
                $methodContent = implode("\n", array_slice($lines, $startLine, $endLine - $startLine));
                $newClassContent .= "\n\n".$methodContent;
            }

            $newClassContent .= "\n}\n";

            // Ensure that each class is only added once
            if (! isset($classContents[$className])) {
                $classContents[$className] = $newClassContent;
            }
        }

        // Combine all class contents
        $combinedContent = implode("\n\n", $classContents);

        // Save to file
        Storage::disk(config('minifier.disk'))->put(config('minifier.path'), $combinedContent);
    }

    private function getTraitMethodReflection(ReflectionMethod $method): ?ReflectionMethod
    {
        foreach ($method->getDeclaringClass()->getTraits() as $trait) {
            if ($trait->hasMethod($method->getName())) {
                return $trait->getMethod($method->getName());
            }
        }

        return null;
    }

    private function extractUseStatements($fileContent)
    {
        $useStatements = [];

        // Split the file content into lines
        $lines = explode("\n", $fileContent);

        // Iterate through the lines and extract use statements
        foreach ($lines as $line) {
            // Check if the line starts with 'use'
            if (preg_match('/^\s*use\s+[a-zA-Z0-9_\\\\]+;/', $line)) {
                $useStatements[] = trim($line);
            } elseif (! empty(trim($line)) && ! str_starts_with(trim($line), 'use')) {
                // Stop parsing when we reach a line that is neither a 'use' statement nor empty
                continue;
            }
        }

        return implode("\n", $useStatements);
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\CodeParser;

use Illuminate\Support\Facades\Log;
use ReflectionClass;
use ReflectionMethod;
use SplFileObject;

class MethodAnalysisService
{
    private array $requiredMethods = [];

    public function analyze_class($className, $methodName = null): array
    {
        $reflection = $this->get_reflection_class($className);
        if (! $reflection) {
            return [];
        }
        $currentNamespace = $reflection->getNamespaceName();

        $allowed_namespaces = collect(config('minifier.namespaces', ['App']));
        if (! $allowed_namespaces->contains($currentNamespace)) {
            return [];
        }

        $this->requiredMethods[$reflection->getName()] = [];

        if ($methodName) {
            $methods = $this->analyze_specific_method($reflection, $methodName, $className);
        } else {
            $methods = $this->analyze_all_methods($reflection);
        }

        [$traits, $traitAliases] = $this->collectTraits($reflection);

        foreach ($traits as $traitName) {
            $traitReflection = new ReflectionClass($traitName);
            foreach ($traitReflection->getMethods() as $traitMethod) {
                $methodName = $traitMethod->getName();

                if (isset($traitAliases[$methodName])) {
                    $aliasedMethodName = $traitAliases[$methodName];
                    $this->requiredMethods[$reflection->getName()] ??= [];
                    if (!in_array($aliasedMethodName, $this->requiredMethods[$reflection->getName()])) {
                        $this->requiredMethods[$reflection->getName()][] = $aliasedMethodName;
                    }
                } else {
                    $this->requiredMethods[$traitName] ??= [];
                    if (!in_array($methodName, $this->requiredMethods[$traitName])) {
                        $this->requiredMethods[$traitName][] = $methodName;
                    }
                }
            }
        }

        $useStatements = $this->get_use_statements($reflection);

        foreach ($methods as $method) {
            $calls = $this->analyze_method($method, $useStatements, $currentNamespace);

            foreach ($calls as $call) {
                if (! array_key_exists($call['class'], $this->requiredMethods) ||
                    ! in_array($call['method'], $this->requiredMethods[$call['class']])) {
                    $this->requiredMethods[$call['class']][] = $call['method'];
                }
                // Recursively analyze the called class
                $this->analyze_class($call['class']);
            }
        }

        return $this->requiredMethods;
    }

    private function collectTraits(ReflectionClass $class): array
    {
        $traits = [];
        $traitAliases = [];

        while ($class) {
            $traitNames = $class->getTraitNames();
            foreach ($traitNames as $traitName) {
                $trait = new ReflectionClass($traitName);
                $traits[] = $traitName;

                foreach ($class->getTraitAliases() as $method => $alias) {
                    if ($trait->hasMethod($method)) {
                        $traitAliases[$alias] = $method;
                    }
                }
            }

            $class = $class->getParentClass();
        }

        return [$traits, $traitAliases];
    }

    protected function is_allowed_namespace($namespace): bool
    {
        $allowedNamespaces = config('minifier.namespaces', ['App']);
        foreach ($allowedNamespaces as $allowedNamespace) {
            if (strpos($namespace, $allowedNamespace) === 0) {
                return true;
            }
        }

        return false;
    }

    public function get_own_methods(ReflectionClass $reflection): array
    {
        $own_methods = array_filter($reflection->getMethods(ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED | ReflectionMethod::IS_PRIVATE), function ($method) use ($reflection) {
            return $method->getDeclaringClass()->getName() === $reflection->getName();
        });

        $methodNames = array_map(fn ($method) => $method->getName(), $own_methods);
        error_log('Own Methods in class '.$reflection->getName().': '.implode(', ', $methodNames));

        return $own_methods;

    }

    public function analyze_method(ReflectionMethod $method, array $useStatements, $currentNamespace): array
    {
        $methodBody = $this->get_method_body($method);
        $methodCalls = [];

        // Match both variable method calls and direct instantiation
        if (preg_match_all('/\bnew\s+([a-zA-Z0-9_]+)\b/', $methodBody, $matches)) {
            foreach ($matches[1] as $className) {
                // If the class name does not include a namespace, prepend the current namespace
                if (! str_contains($className, '\\')) {
                    $className = $currentNamespace.'\\'.$className;
                }

                // Check if the class exists
                if (class_exists($className)) {
                    // If the class exists, add it to the method calls with a placeholder method name
                    // Placeholder is used because the actual method name is not captured in this regex
                    $methodCalls[] = ['class' => $className, 'method' => '__construct'];
                }
            }
        }

        return $methodCalls;
    }

    public function get_method_body(ReflectionMethod $method): string
    {
        $filePath = $method->getFileName();
        $startLine = $method->getStartLine() - 1; // Adjust for zero-based indexing
        $endLine = $method->getEndLine();

        $file = new SplFileObject($filePath);
        $file->seek($startLine);

        $methodBody = '';

        while ($file->key() < $endLine) {
            $methodBody .= $file->current();
            $file->next();
        }

        return $methodBody;
    }

    public function get_use_statements(ReflectionClass $reflection): array
    {
        $contents = file_get_contents($reflection->getFileName());
        $useStatements = [];

        $namespaces = config('minifier.namespaces', ['App']);

        // Build a regex pattern dynamically based on the namespaces.
        $namespacePattern = implode('|', array_map(fn ($ns) => preg_quote($ns, '/'), $namespaces));
        $pattern = "/^use\s+({$namespacePattern}\\\\[a-zA-Z0-9_\\\\]+)(\s+as\s+([a-zA-Z0-9_]+))?;/m";

        if (preg_match_all(pattern: $pattern, subject: $contents, matches: $matches, flags: PREG_SET_ORDER)) {
            foreach ($matches as $match) {
                $fullClassName = $match[1];
                $shortName = $match[3] ?? class_basename($fullClassName); // Use "class_basename" to get the short name if "as" alias is not used
                $useStatements[$shortName] = $fullClassName;
            }
        }

        return $useStatements;
    }

    private function get_reflection_class($className): ?ReflectionClass
    {
        try {
            $reflection = new ReflectionClass($className);
        } catch (\ReflectionException $e) {
            Log::error('Class analysis failed: '.$e->getMessage());

            // Re-throw the exception if you want to ensure that calling code can also handle it
            return null;
        }

        return $reflection;
    }

    private function analyze_specific_method(ReflectionClass $reflection, mixed $methodName, $className): array
    {
        if ($reflection->hasMethod($methodName) &&
            $reflection->getMethod($methodName)->getDeclaringClass()->getName() === $className) {
            $this->requiredMethods[$reflection->getName()][] = $methodName;
            $methods = [$reflection->getMethod($methodName)];
        } else {
            $methods = [];
        }

        return $methods;
    }

    private function analyze_all_methods(ReflectionClass $reflection): array
    {
        $methods = $this->get_own_methods($reflection);

        foreach ($methods as $method) {
            $this->requiredMethods[$reflection->getName()][] = $method->getName();
        }

        // Handle abstract methods
        if ($reflection->isAbstract()) {
            $abstractMethods = $reflection->getMethods(ReflectionMethod::IS_ABSTRACT);
            foreach ($abstractMethods as $abstractMethod) {
                $this->requiredMethods[$reflection->getName()][] = $abstractMethod->getName();
            }
        }

        $parentClass = $reflection->getParentClass();
        if ($parentClass && $this->is_allowed_namespace($parentClass->getNamespaceName())) {
            foreach ($this->get_own_methods($parentClass) as $parentMethod) {
                if ($parentMethod->isProtected() || $parentMethod->isPublic()) {
                    $this->requiredMethods[$parentClass->getName()][] = $parentMethod->getName();
                }
            }
        }

        return $methods;
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\File;

class LaravelMinifierCommand extends Command
{
    public $signature = 'laravel-minifier';

    public $description = 'My command';

    public function handle()
    {
        $directories = ['config', 'src', 'tests'];
        $blobPath = base_path('all_files.txt');

        foreach ($directories as $directory) {
            $files = File::allFiles($directory);

            foreach ($files as $file) {
                File::append($blobPath, File::get($file));
            }
        }

        $this->info('All files have been compiled into blob.txt.');
    }

    private function traverseDirectory($directory, $blobPath)
    {
        $files = File::allFiles($directory);

        foreach ($files as $file) {
            File::append($blobPath, File::get($file));
        }
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Facades;

use Illuminate\Support\Facades\Facade;

/**
 * @see \Shawnveltman\LaravelMinifier\LaravelMinifier
 */
class LaravelMinifier extends Facade
{
    protected static function getFacadeAccessor()
    {
        return \Shawnveltman\LaravelMinifier\LaravelMinifier::class;
    }
}
<?php

namespace Shawnveltman\LaravelMinifier;

class LaravelMinifier
{
}
<?php

namespace Shawnveltman\LaravelMinifier;

use Shawnveltman\LaravelMinifier\Commands\LaravelMinifierCommand;
use Spatie\LaravelPackageTools\Package;
use Spatie\LaravelPackageTools\PackageServiceProvider;

class LaravelMinifierServiceProvider extends PackageServiceProvider
{
    public function configurePackage(Package $package): void
    {
        /*
         * This class is a Package Service Provider
         *
         * More info: https://github.com/spatie/laravel-package-tools
         */
        $package
            ->name('laravel-minifier')
            ->hasConfigFile()
//            ->hasViews()
//            ->hasMigration('create_laravel-minifier_table')
            ->hasCommand(LaravelMinifierCommand::class);
    }
}
<?php

// config for Shawnveltman/LaravelMinifier
return [
    'path' => env('MINIFIER_PATH', 'ai_rag/classes.txt'),
    'disk' => env('MINIFIER_DISK', 'local'),
    'namespaces' => [
        'App',
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
        // Add additional namespaces as needed...
    ],
];
<?php

namespace Shawnveltman\LaravelMinifier\CodeParser;

use Illuminate\Support\Facades\Storage;
use ReflectionClass;
use ReflectionMethod;

<?php

namespace Shawnveltman\LaravelMinifier\CodeParser;

use Illuminate\Support\Facades\Storage;
use ReflectionClass;
use ReflectionMethod;

class ClassContentService
{
    public function createClassFiles(array $requiredClassesAndMethods): void
    {
        $classContents = [];

        foreach ($requiredClassesAndMethods as $className => $methods)
        {
            $reflection  = new ReflectionClass($className);
            $fileContent = file_get_contents($reflection->getFileName());
            $lines       = explode("\n", $fileContent);

            // Manually reconstruct the class definition
            $namespace       = $reflection->getNamespaceName();
            $useStatements   = $this->extractUseStatements($fileContent);
            $classDefinition = "class {$reflection->getShortName()}";

            // Add namespace and use statements
            $newClassContent = "<?php\n\nnamespace {$namespace};\n\n{$useStatements}\n\n{$classDefinition}\n{";

            // Add each required method
            foreach ($methods as $methodName)
            {
                $methodReflection = new ReflectionMethod($className, $methodName);
                $startLine        = $methodReflection->getStartLine() - 1;
                $endLine          = $methodReflection->getEndLine();
                $methodContent    = implode("\n", array_slice($lines, $startLine, $endLine - $startLine));
                $newClassContent .= "\n\n" . $methodContent;
            }

            $newClassContent .= "\n}\n";

            $classContents[] = $newClassContent;
        }

        // Combine all class contents
        $combinedContent = implode("\n\n", $classContents);

        // Save to file
        Storage::disk(config('minifier.disk'))->put(config('minifier.path'), $combinedContent);
    }

    private function extractUseStatements($fileContent)
    {
        $useStatements = [];

        // Split the file content into lines
        $lines = explode("\n", $fileContent);

        // Iterate through the lines and extract use statements
        foreach ($lines as $line)
        {
            // Check if the line starts with 'use'
            if (preg_match('/^\s*use\s+[a-zA-Z0-9_\\\\]+;/', $line))
            {
                $useStatements[] = trim($line);
            } elseif (! empty(trim($line)) && ! str_starts_with(trim($line), 'use'))
            {
                // Stop parsing when we reach a line that is neither a 'use' statement nor empty
                break;
            }
        }

        return implode("\n", $useStatements);
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\CodeParser;

use ReflectionClass;
use ReflectionMethod;
use SplFileObject;

class MethodAnalysisService
{
    private array $requiredMethods = [];

    public function analyzeClass($className, $methodName = null)
    {
        $reflection = new ReflectionClass($className);
        ray("Analyzing Class: " . $className . " in file " . $reflection->getFileName());

        $this->requiredMethods[$reflection->getName()] = [];

        if ($methodName) {
            if ($reflection->hasMethod($methodName) &&
                $reflection->getMethod($methodName)->getDeclaringClass()->getName() === $className) {
                $this->requiredMethods[$reflection->getName()][] = $methodName;
                $methods = [$reflection->getMethod($methodName)];
            } else {
                $methods = [];
            }
        } else {
            $methods = $this->getOwnMethods($reflection);
            foreach ($methods as $method) {
                $this->requiredMethods[$reflection->getName()][] = $method->getName();
            }

            $parentClass = $reflection->getParentClass();
            if ($parentClass && $this->isAllowedNamespace($parentClass->getNamespaceName())) {
                foreach ($this->getOwnMethods($parentClass) as $parentMethod) {
                    if ($parentMethod->isProtected() || $parentMethod->isPublic()) {
                        $this->requiredMethods[$parentClass->getName()][] = $parentMethod->getName();
                    }
                }
            }
        }

        $useStatements = $this->getUseStatements($reflection);

        foreach ($methods as $method) {
            $calls = $this->analyzeMethod($method, $useStatements);

            foreach ($calls as $call) {
                if (!array_key_exists($call['class'], $this->requiredMethods) ||
                    !in_array($call['method'], $this->requiredMethods[$call['class']])) {
                    $this->requiredMethods[$call['class']][] = $call['method'];
                }
                $this->analyzeClass($call['class'], $call['method']);
            }
        }

        return $this->requiredMethods;
    }

    protected function isAllowedNamespace($namespace): bool
    {
        $allowedNamespaces = config('minifier.namespaces', ['App']);
        foreach ($allowedNamespaces as $allowedNamespace) {
            if (strpos($namespace, $allowedNamespace) === 0) {
                return true;
            }
        }
        return false;
    }

    public function getOwnMethods(ReflectionClass $reflection): array
    {
        $own_methods = array_filter($reflection->getMethods(ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED | ReflectionMethod::IS_PRIVATE), function ($method) use ($reflection)
        {
            return $method->getDeclaringClass()->getName() === $reflection->getName();
        });

        $methodNames = array_map(fn($method) => $method->getName(), $own_methods);
        error_log("Own Methods in class " . $reflection->getName() . ": " . implode(', ', $methodNames));

        return $own_methods;

    }

    public function analyzeMethod(ReflectionMethod $method, array $useStatements)
    {
        $methodBody  = $this->getMethodBody($method);
        $methodCalls = [];

        if (preg_match_all('/\b([a-zA-Z0-9_]+)\??->([a-zA-Z0-9_]+)\(/', $methodBody, $matches, PREG_SET_ORDER))
        {
            foreach ($matches as $match)
            {
                $calledMethodName = $match[2];
                // Find the class that contains the method
                $className = $this->findClassForMethod($calledMethodName, $useStatements);

                if ($className)
                {
                    $methodCalls[] = ['class' => $className, 'method' => $calledMethodName];
                }
            }
        }

        return $methodCalls;
    }

    public function findClassForMethod($methodName, array $useStatements)
    {
        foreach ($useStatements as $shortName => $fullClassName)
        {
            if (method_exists($fullClassName, $methodName))
            {
                return $fullClassName;
            }
        }

        return null;
    }

    public function getMethodBody(ReflectionMethod $method): string
    {
        $filePath  = $method->getFileName();
        $startLine = $method->getStartLine() - 1; // Adjust for zero-based indexing
        $endLine   = $method->getEndLine();

        $file = new SplFileObject($filePath);
        $file->seek($startLine);

        $methodBody = '';

        while ($file->key() < $endLine)
        {
            $methodBody .= $file->current();
            $file->next();
        }

        return $methodBody;
    }

    public function getUseStatements(ReflectionClass $reflection): array
    {
        $contents      = file_get_contents($reflection->getFileName());
        $useStatements = [];

        $namespaces = config('minifier.namespaces', ['App']);

        // Build a regex pattern dynamically based on the namespaces.
        $namespacePattern = implode('|', array_map(fn($ns) => preg_quote($ns, '/'), $namespaces));
        $pattern = "/^use\s+({$namespacePattern}\\\\[a-zA-Z0-9_\\\\]+)(\s+as\s+([a-zA-Z0-9_]+))?;/m";

        if (preg_match_all(pattern: $pattern, subject: $contents, matches: $matches, flags: PREG_SET_ORDER))
        {
            foreach ($matches as $match)
            {
                $fullClassName             = $match[1];
                $shortName                 = $match[3] ?? class_basename($fullClassName); // Use "class_basename" to get the short name if "as" alias is not used
                $useStatements[$shortName] = $fullClassName;
            }
        }

        return $useStatements;
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

abstract class AbstractClassWithMethods
{
    // An example of an abstract method
    abstract protected function abstractMethod();

    // This class may also have non-abstract methods
    public function concreteMethod()
    {
        // Implementation of a concrete method
    }
}

<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

use Illuminate\Support\Collection as BaseCollection;
use Illuminate\Support\Facades\Config;

class AliasesUseStatementClass
{
    public function methodWithAliasUse()
    {
        BaseCollection::times(3);
        Config::get('app.timezone');
    }
}

<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class BaseClass
{
    public function parentMethod(): string
    {
        return 'Parent Method';
    }

    protected function parentProtectedMethod()
    {
        // Protected Method content
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class ChildClass extends BaseClass {
    public function childMethod() {
        $hello = $this->parentMethod();
        $this->parentProtectedMethod();
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

use Shawnveltman\LaravelMinifier\Tests\Fixtures\ExampleTrait;

class ClassWithTrait
{
    use ExampleTrait;

    public function methodUsingTrait()
    {
        $this->traitMethod();
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

use Shawnveltman\LaravelMinifier\Tests\Fixtures\OtherClass;

class DirectInstantiationClass
{
    public function methodWithInstantiation()
    {
        $instance = new OtherClass();
        $instance->doSomething();
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class EmptyClass
{
    // No methods or properties
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

trait ExampleTrait
{
    public function traitMethod()
    {
        // Trait Method content
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class MultipleMethodsClass
{
    public function firstMethod()
    {
        $this->secondMethod();
    }

    public function secondMethod()
    {
        // Second Method content
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class OtherClass
{
    public function doSomething(): void
    {
        // Do something
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class StaticMethodClass
{
    public static function staticMethod()
    {
        // Static Method content
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

use Illuminate\Support\Collection;

class UseStatementClass
{
    public function methodWithUse()
    {
        return Collection::make();
    }
}

<?php

namespace Shawnveltman\LaravelMinifier\Tests\Feature;

use Exception;
use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Shawnveltman\LaravelMinifier\CodeParser\ClassContentService;
use Shawnveltman\LaravelMinifier\CodeParser\MethodAnalysisService;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\
{AbstractClassWithMethods,
    AliasesUseStatementClass,
    BaseClass,
    ChildClass,
    ClassWithTrait,
    DirectInstantiationClass,
    EmptyClass,
    MultipleMethodsClass,
    OtherClass,
    StaticMethodClass};


it('analyzes a class and returns all own method dependencies', function () {
    Config::set('minifier.namespaces', [
        'App',
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
    ]);
    $analysisService = new MethodAnalysisService();

    // Analyze the BaseClass which has no dependencies.
    $values = $analysisService->analyzeClass(BaseClass::class);
    expect($values)->toBeArray();

    // Now analyze the ChildClass which should have dependencies based on the parentMethod and parentProtectedMethod.
    $values = $analysisService->analyzeClass(ChildClass::class);

    expect($values)->toBeArray();
    // We should see BaseClass's methods in the returned array.
    expect($values)->toHaveKey(BaseClass::class);
    expect($values[BaseClass::class])->toContain('parentMethod');
    expect($values[BaseClass::class])->toContain('parentProtectedMethod');
});

it('creates class files with the required methods', function () {
    Config::set('minifier.namespaces', [
        'App',
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
    ]);
    $contentService  = new ClassContentService();
    $analysisService = new MethodAnalysisService();

    // Mock Storage Facade to prevent actual filesystem interaction
    Storage::fake('local');

    // Use MethodAnalysisService to get the correct set of classes and methods
    $requiredClassesAndMethods = $analysisService->analyzeClass(ChildClass::class);

    Config::set('minifier.disk', 'local');
    Config::set('minifier.path', 'output.php');

    $contentService->createClassFiles($requiredClassesAndMethods);

    // Assert that the file was created
    Storage::disk('local')->assertExists('output.php');

    // Obtain the content of the stored file
    $content = Storage::disk('local')->get('output.php');

    // Assertions based on the expected content of the file.
    // Check if the ChildClass and the methods it uses from the BaseClass are generated in the output.

    expect($content)->toContain('class ChildClass');
    expect($content)->toContain('function childMethod()');

    expect($content)->toContain('class BaseClass');
    expect($content)->toContain('function parentMethod()');
    expect($content)->toContain('function parentProtectedMethod()');

    // Test if the ClassContentService successfully removes the methods not listed in the $requiredClassesAndMethods
    // Assuming that BaseClass has other methods that aren't used and shouldn't be in the output
    expect($content)->not->toContain('function someOtherMethod()');
});

it('analyzes a class with multiple methods and tracks their dependencies', function () {
    $analysisService = new MethodAnalysisService();

    // Analyze MultipleMethodsClass which has internal method dependencies.
    $values = $analysisService->analyzeClass(MultipleMethodsClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(MultipleMethodsClass::class);
    expect($values[MultipleMethodsClass::class])->toContain('firstMethod');
    expect($values[MultipleMethodsClass::class])->toContain('secondMethod');
});

it('analyzes a class using a trait and includes the trait methods', function () {
    $analysisService = new MethodAnalysisService();

    // Analyze ClassWithTrait which uses a trait with its own methods.
    $values = $analysisService->analyzeClass(ClassWithTrait::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey("Shawnveltman\LaravelMinifier\Tests\Fixtures\ExampleTrait");
//    expect($values["Shawnveltman\LaravelMinifier\Tests\Fixtures\ClassWithTrait"])->toContain('methodUsingTrait');
    expect($values["Shawnveltman\LaravelMinifier\Tests\Fixtures\ExampleTrait"])->toContain('traitMethod');
});

it('analyzes a class using a trait and includes the trait methods and methods of the class itself', function () {
    $analysisService = new MethodAnalysisService();

    // Analyze ClassWithTrait which uses a trait with its own methods.
    $values = $analysisService->analyzeClass(ClassWithTrait::class);

    // Validate that the array of dependencies was returned.
    expect($values)->toBeArray();

    // Ensure the trait is included as a dependency.
    expect($values)->toHaveKey("Shawnveltman\LaravelMinifier\Tests\Fixtures\ExampleTrait");

    // Ensure that the method from the trait is included.
    expect($values["Shawnveltman\LaravelMinifier\Tests\Fixtures\ExampleTrait"])->toContain('traitMethod');
    // Ensure that the class being analyzed is included with its own methods.
    expect($values)->toHaveKey("Shawnveltman\LaravelMinifier\Tests\Fixtures\ClassWithTrait");
    expect($values["Shawnveltman\LaravelMinifier\Tests\Fixtures\ClassWithTrait"])->toContain('methodUsingTrait');
});

it('throws an exception when a nonexistent class is analyzed', function () {
    $analysisService = new MethodAnalysisService();
    $nonExistentClass = 'NonExistentClass';
    $analysisService->analyzeClass($nonExistentClass);
})->throws(Exception::class);

it('throws an exception when a non-class is passed', function () {
    $analysisService = new MethodAnalysisService();
    $nonClass = 'SomeRandomString';
    $analysisService->analyzeClass($nonClass);
})->throws(Exception::class);

it('analyzes abstract classes and abstract methods correctly', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyzeClass(AbstractClassWithMethods::class);
    expect($values)->toBeArray();
    expect($values[AbstractClassWithMethods::class])->toContain('abstractMethod');
});

it('handles use statements with aliases correctly', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyzeClass(AliasesUseStatementClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(AliasesUseStatementClass::class);
    expect($values[AliasesUseStatementClass::class])->toContain('methodWithAliasUse');
});

it('tracks classes instantiated within methods', function() {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyzeClass(DirectInstantiationClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(DirectInstantiationClass::class);
    expect($values[DirectInstantiationClass::class])->toContain('methodWithInstantiation');
    expect($values)->toHaveKey(OtherClass::class);
    expect($values[OtherClass::class])->toContain('doSomething');
});

it('includes protected parent methods accessed by child classes', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyzeClass(ChildClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(BaseClass::class);
    expect($values[BaseClass::class])->toContain('parentProtectedMethod');
});

it('includes depended-upon static methods', function() {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyzeClass(StaticMethodClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(StaticMethodClass::class);
    expect($values[StaticMethodClass::class])->toContain('staticMethod');
});

it('handles empty classes or edge cases appropriately', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyzeClass(EmptyClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(EmptyClass::class);
    expect($values[EmptyClass::class])->toEqual([]);
});

it('handles errors and logs them appropriately when a class file cannot be analyzed', function () {
    $analysisService = new MethodAnalysisService();
    $brokenClassName = 'NonExistentClass';

    Log::shouldReceive('error')
        ->once()
        ->withArgs(fn($message) => str_contains($message, $brokenClassName));

    $analysisService->analyzeClass($brokenClassName);
});

it('handles abstract classes correctly', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyzeClass(AbstractClassWithMethods::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(AbstractClassWithMethods::class);
    expect($values[AbstractClassWithMethods::class])->toContain('concreteMethod');
    expect($values[AbstractClassWithMethods::class])->not->toContain('abstractMethod');
});



<?php

it('will not use debugging functions')
    ->expect(['dd', 'dump', 'ray'])
    ->each->not->toBeUsed();
<?php

namespace External;

class SomeExternalClass
{
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Feature;

use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use ReflectionClass;
use ReflectionMethod;
use Shawnveltman\LaravelMinifier\CodeParser\ClassContentService;
use Shawnveltman\LaravelMinifier\CodeParser\MethodAnalysisService;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\AbstractClassForTesting;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\AbstractClassWithMethods;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\AliasesUseStatementClass;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\BaseClass;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\ChildClass;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\ClassUsingInheritedTraits;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\ClassWithMultipleNamespaceAliases;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\ClassWithTrait;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\DirectInstantiationClass;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\EmptyClass;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\InterfaceImplementingClass;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\InterfaceToImplement;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\MultipleMethodsClass;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\OtherClass;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\StaticMethodClass;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\TestClassWithTraitAliases;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\TestTrait;
use Shawnveltman\LaravelMinifier\Tests\Fixtures\UseStatementClass;

it('analyzes a class and returns all own method dependencies', function () {
    Config::set('minifier.namespaces', [
        'App',
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
    ]);
    $analysisService = new MethodAnalysisService();

    // Analyze the ChildClass which should have dependencies based on the parentMethod and parentProtectedMethod.
    $values = $analysisService->analyze_class(ChildClass::class);

    expect($values)->toBeArray();
    // We should see BaseClass's methods in the returned array.
    expect($values)->toHaveKey(BaseClass::class);
    expect($values[BaseClass::class])->toContain('parentMethod');
    expect($values[BaseClass::class])->toContain('parentProtectedMethod');
});

it('creates class files with the required methods', function () {
    Config::set('minifier.namespaces', [
        'App',
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
    ]);
    $contentService = new ClassContentService();
    $analysisService = new MethodAnalysisService();

    // Mock Storage Facade to prevent actual filesystem interaction
    Storage::fake('local');

    // Use MethodAnalysisService to get the correct set of classes and methods
    $requiredClassesAndMethods = $analysisService->analyze_class(ChildClass::class);

    Config::set('minifier.disk', 'local');
    Config::set('minifier.path', 'output.php');

    $contentService->createClassFiles($requiredClassesAndMethods);

    // Assert that the file was created
    Storage::disk('local')->assertExists('output.php');

    // Obtain the content of the stored file
    $content = Storage::disk('local')->get('output.php');

    // Assertions based on the expected content of the file.
    // Check if the ChildClass and the methods it uses from the BaseClass are generated in the output.

    expect($content)->toContain('class ChildClass');
    expect($content)->toContain('function childMethod()');

    expect($content)->toContain('class BaseClass');
    expect($content)->toContain('function parentMethod()');
    expect($content)->toContain('function parentProtectedMethod()');

    // Test if the ClassContentService successfully removes the methods not listed in the $requiredClassesAndMethods
    // Assuming that BaseClass has other methods that aren't used and shouldn't be in the output
    expect($content)->not->toContain('function someOtherMethod()');
});

it('analyzes a class with multiple methods and tracks their dependencies', function () {
    $analysisService = new MethodAnalysisService();

    // Analyze MultipleMethodsClass which has internal method dependencies.
    $values = $analysisService->analyze_class(MultipleMethodsClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(MultipleMethodsClass::class);
    expect($values[MultipleMethodsClass::class])->toContain('firstMethod');
    expect($values[MultipleMethodsClass::class])->toContain('secondMethod');
});

it('analyzes a class using a trait and includes the trait methods', function () {
    $analysisService = new MethodAnalysisService();

    // Analyze ClassWithTrait which uses a trait with its own methods.
    $values = $analysisService->analyze_class(ClassWithTrait::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey("Shawnveltman\LaravelMinifier\Tests\Fixtures\ExampleTrait");
    //    expect($values["Shawnveltman\LaravelMinifier\Tests\Fixtures\ClassWithTrait"])->toContain('methodUsingTrait');
    expect($values["Shawnveltman\LaravelMinifier\Tests\Fixtures\ExampleTrait"])->toContain('traitMethod');
});

it('analyzes a class using a trait and includes the trait methods and methods of the class itself', function () {
    $analysisService = new MethodAnalysisService();

    // Analyze ClassWithTrait which uses a trait with its own methods.
    $values = $analysisService->analyze_class(ClassWithTrait::class);

    // Validate that the array of dependencies was returned.
    expect($values)->toBeArray();

    // Ensure the trait is included as a dependency.
    expect($values)->toHaveKey("Shawnveltman\LaravelMinifier\Tests\Fixtures\ExampleTrait");

    // Ensure that the method from the trait is included.
    expect($values["Shawnveltman\LaravelMinifier\Tests\Fixtures\ExampleTrait"])->toContain('traitMethod');
    // Ensure that the class being analyzed is included with its own methods.
    expect($values)->toHaveKey("Shawnveltman\LaravelMinifier\Tests\Fixtures\ClassWithTrait");
    expect($values["Shawnveltman\LaravelMinifier\Tests\Fixtures\ClassWithTrait"])->toContain('methodUsingTrait');
});

it('returns empty array for nonexistant class', function () {
    $analysisService = new MethodAnalysisService();
    $nonExistentClass = 'NonExistentClass';
    $values = $analysisService->analyze_class($nonExistentClass);
    expect($values)->toBeArray();
    expect($values)->toEqual([]);
});

it('throws an exception when a non-class is passed', function () {
    $analysisService = new MethodAnalysisService();
    $nonClass = 'SomeRandomString';
    $values = $analysisService->analyze_class($nonClass);
    expect($values)->toBeArray();
    expect($values)->toEqual([]);
});

it('analyzes abstract classes and abstract methods correctly', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyze_class(AbstractClassWithMethods::class);
    expect($values)->toBeArray();
    expect($values[AbstractClassWithMethods::class])->toContain('abstractMethod');
});

it('handles use statements with aliases correctly', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyze_class(AliasesUseStatementClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(AliasesUseStatementClass::class);
    expect($values[AliasesUseStatementClass::class])->toContain('methodWithAliasUse');
});

it('includes protected parent methods accessed by child classes', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyze_class(ChildClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(BaseClass::class);
    expect($values[BaseClass::class])->toContain('parentProtectedMethod');
});

it('includes depended-upon static methods', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyze_class(StaticMethodClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(StaticMethodClass::class);
    expect($values[StaticMethodClass::class])->toContain('staticMethod');
});

it('handles empty classes or edge cases appropriately', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyze_class(EmptyClass::class);
    expect($values)->toEqual([EmptyClass::class => []]);
});

it('resolves trait inheritance dependencies correctly', function () {
    Config::set('minifier.namespaces', [
        'App',
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
    ]);
    $analysisService = new MethodAnalysisService();

    $values = $analysisService->analyze_class(ClassUsingInheritedTraits::class);

    expect($values)->toBeArray();
    expect($values)->toHaveKey(ClassUsingInheritedTraits::class);
    expect($values[ClassUsingInheritedTraits::class])->toContain('inheritedTraitMethod');
})->skip(fn () => ! class_exists(ClassUsingInheritedTraits::class));

it('analyzes classes implementing interfaces correctly', function () {
    $analysisService = new MethodAnalysisService();

    // Assuming `InterfaceImplementingClass` implements `InterfaceToImplement`
    $values = $analysisService->analyze_class(InterfaceImplementingClass::class);

    expect($values)->toBeArray();
    expect($values)->toHaveKey(InterfaceImplementingClass::class);

    // Use reflection to get the methods from the interface
    $interfaceReflection = new ReflectionClass(InterfaceToImplement::class);
    $methods = $interfaceReflection->getMethods(ReflectionMethod::IS_PUBLIC);

    foreach ($methods as $method) {
        expect($values[InterfaceImplementingClass::class])->toContain($method->getName());
    }

})->skip(fn () => ! interface_exists(InterfaceToImplement::class) || ! class_exists(InterfaceImplementingClass::class));
it('manages multiple namespace aliases correctly', function () {
    $analysisService = new MethodAnalysisService();

    $values = $analysisService->analyze_class(ClassWithMultipleNamespaceAliases::class);

    expect($values)->toBeArray();
    expect($values[ClassWithMultipleNamespaceAliases::class])->toBe(['methodWithMultipleAliases']);
})->skip(fn () => ! class_exists(ClassWithMultipleNamespaceAliases::class));

it('handles errors and logs them appropriately when a class file cannot be analyzed', function () {
    $analysisService = new MethodAnalysisService();
    $brokenClassName = 'NonExistentClass';

    Log::shouldReceive('error')
        ->once()
        ->withArgs(fn ($message) => str_contains($message, $brokenClassName));

    $values = $analysisService->analyze_class($brokenClassName);
    expect($values)->toBeArray();
    expect($values)->toEqual([]);
});

it('ensures the initial class is not added twice', function () {
    // Set up the allowed namespaces configuration
    Config::set('minifier.namespaces', [
        'App',
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
    ]);

    // Instantiate the MethodAnalysisService
    $analysisService = new MethodAnalysisService();

    // Analyze a class that is known to have dependencies
    // Replace 'YourInitialClass' with the actual class you want to test
    $values = $analysisService->analyze_class(UseStatementClass::class);

    // Check that the array has keys for each class
    expect($values)->toBeArray();

    // Check that the initial class is listed only once
    $initialClassOccurrences = array_reduce($values, function ($carry, $methods) use ($values) {
        $className = array_search($methods, $values);

        return $carry + ($className === UseStatementClass::class ? 1 : 0);
    }, 0);

    expect($initialClassOccurrences)->toEqual(1);
});

it('tracks classes instantiated within methods', function () {
    $analysisService = new MethodAnalysisService();
    $values = $analysisService->analyze_class(DirectInstantiationClass::class);
    expect($values)->toBeArray();
    expect($values)->toHaveKey(DirectInstantiationClass::class);
    expect($values[DirectInstantiationClass::class])->toContain('methodWithInstantiation');
    ray($values);
    expect($values)->toHaveKey(OtherClass::class);
    expect($values[OtherClass::class])->toContain('doSomething');
});

it('collects methods from classes that are called within the analyzed class', function () {
    Config::set('minifier.namespaces', [
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
    ]);
    $analysisService = new MethodAnalysisService();

    // Analyze MultipleMethodsClass which has internal method dependencies.
    $values = $analysisService->analyze_class(MultipleMethodsClass::class);
    // Expect the second method to be detected as a dependency
    expect($values[MultipleMethodsClass::class])->toContain('secondMethod');
});

//// TODO: Implement this at some point later
//it('collects methods from nested traits used within the analyzed class', function () {
//    Config::set('minifier.namespaces', [
//        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
//    ]);
//    $analysisService = new MethodAnalysisService();
//
//    $values = $analysisService->analyze_class(ClassUsingInheritedTraits::class);
//
//    ray($values);
//    // Expect the nested trait method to be detected
//    expect($values)->toHaveKey(ParentTrait::class);
//    expect($values[ParentTrait::class])->toContain('inheritedTraitMethod');
//});

it('does not analyze classes that are outside of the configured namespaces', function () {
    $analysisService = new MethodAnalysisService();
    $outsideNamespaceClass = 'External\SomeExternalClass';

    Config::set('minifier.namespaces', [
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
        // Do not include 'External' namespace here
    ]);

    $values = $analysisService->analyze_class($outsideNamespaceClass);
    ray($values);
    expect(isset($values[$outsideNamespaceClass]))->toBeFalse();
});

it('captures the full class definition with parent classes and interfaces', function () {
    // Assuming we have a test class with a parent and interface.
    // You'll need to create these examples in the Fixtures, similar to existing ones.

    $requiredClassesAndMethods = [
        ChildClass::class => ['childMethod'],
    ];
    $contentService = new ClassContentService();

    Storage::fake('local');
    Config::set('minifier.disk', 'local');
    Config::set('minifier.path', 'output.php');

    $contentService->createClassFiles($requiredClassesAndMethods);

    $storedContent = Storage::disk('local')->get('output.php');

    // These are basic string checks, but you could enhance by actually checking PHP syntax/parsing if needed
    expect($storedContent)->toContain('class ChildClass extends BaseClass');
    expect($storedContent)->toContain('implements SomeInterface'); // If ChildClass implements SomeInterface
});

it('analyzes class with trait aliases', function () {
    $service = new MethodAnalysisService();

    $className = TestClassWithTraitAliases::class;
    $expectedMethods = [
        $className => ['anotherMethod', 'aliasedTraitMethod', 'traitMethod'],
        TestTrait::class => ['traitMethod'],
    ];

    $result = $service->analyze_class($className);

    expect($result)->toBe($expectedMethods);
});

it('analyzes abstract classes and their methods correctly', function () {
    $analysisService = new MethodAnalysisService();

    Config::set('minifier.namespaces', [
        'App',
        'Shawnveltman\LaravelMinifier\Tests\Fixtures',
    ]);

    $values = $analysisService->analyze_class(AbstractClassForTesting::class);

    expect($values)->toBeArray();
    expect($values)->toHaveKey(AbstractClassForTesting::class);
    expect($values[AbstractClassForTesting::class])->toContain('abstractMethod');
    expect($values[AbstractClassForTesting::class])->toContain('concreteMethod');
});
<?php

use Illuminate\Support\Facades\File;

test('hello', function () {
    $directories = ['config', 'src', 'tests'];
    $blobPath = 'all_files.txt';
    unlink('all_files.txt');
    foreach ($directories as $directory) {
        $files = File::allFiles($directory);

        foreach ($files as $file) {
            File::append($blobPath, File::get($file));
        }
    }

    expect(true)->toBeTrue();
});
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

abstract class AbstractClassForTesting
{
    abstract public function abstractMethod();
    public function concreteMethod() {}
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

abstract class AbstractClassWithMethods
{
    // An example of an abstract method
    abstract protected function abstractMethod();

    // This class may also have non-abstract methods
    public function concreteMethod()
    {
        // Implementation of a concrete method
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

use Illuminate\Support\Collection as BaseCollection;
use Illuminate\Support\Facades\Config;

class AliasesUseStatementClass
{
    public function methodWithAliasUse()
    {
        BaseCollection::times(3);
        Config::get('app.timezone');
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class BaseClass
{
    public function parentMethod(): string
    {
        return 'Parent Method';
    }

    protected function parentProtectedMethod()
    {
        // Protected Method content
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class ChildClass extends BaseClass implements SomeInterface
{
    public function childMethod()
    {
        $hello = $this->parentMethod();
        $this->parentProtectedMethod();
    }

    public function interfaceMethod()
    {
        // TODO: Implement interfaceMethod() method.
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

trait ChildTrait
{
    use ParentTrait;
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class ClassUsingInheritedTraits
{
    use ChildTrait;
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

use Another\Namespace\ClassB as Second;
use Some\Namespace\ClassA as First;

class ClassWithMultipleNamespaceAliases
{
    public function methodWithMultipleAliases(First $first, Second $second)
    {
        // Implementation...
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class ClassWithTrait
{
    use ExampleTrait;

    public function methodUsingTrait()
    {
        $this->traitMethod();
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class ConcreteClassForTesting extends AbstractClassForTesting
{
    public function abstractMethod() {}
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class DirectInstantiationClass
{
    public function methodWithInstantiation()
    {
        $instance = new OtherClass();
        $instance->doSomething();
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class EmptyClass
{
    // No methods or properties
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

trait ExampleTrait
{
    public function traitMethod()
    {
        // Trait Method content
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class InterfaceImplementingClass implements InterfaceToImplement
{
    public function interfaceMethod()
    {
        return 'implementation of interface method';
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

interface InterfaceToImplement
{
    public function interfaceMethod();
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class MultipleMethodsClass
{
    public function firstMethod()
    {
        $this->secondMethod();
    }

    public function secondMethod()
    {
        // Second Method content
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class OtherClass
{
    public function doSomething(): void
    {
        // Do something
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

trait ParentTrait
{
    public function inheritedTraitMethod()
    {
        return 'from inherited trait';
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

interface SomeInterface
{
    public function interfaceMethod();
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class StaticMethodClass
{
    public static function staticMethod()
    {
        // Static Method content
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

class TestClassWithTraitAliases
{
    use TestTrait {
        traitMethod as aliasedTraitMethod;
    }

    public function anotherMethod()
    {
        // ...
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

trait TestTrait
{
    public function traitMethod()
    {
        $hello = 'world';
    }
}
<?php

namespace Shawnveltman\LaravelMinifier\Tests\Fixtures;

use Illuminate\Support\Collection;

class UseStatementClass
{
    public function methodWithUse()
    {
        return Collection::make();
    }
}
<?php

use Illuminate\Support\Facades\Config;
use Shawnveltman\LaravelMinifier\Tests\TestCase;

uses(TestCase::class)->in(__DIR__);

uses()->beforeEach(function () {
    // Mock configuration used by the Package
    Config::set('minifier.disk', 'local');
    Config::set('minifier.path', 'output.php');
});
<?php

namespace Shawnveltman\LaravelMinifier\Tests;

use Illuminate\Database\Eloquent\Factories\Factory;
use Orchestra\Testbench\TestCase as Orchestra;
use Shawnveltman\LaravelMinifier\LaravelMinifierServiceProvider;

class TestCase extends Orchestra
{
    protected function setUp(): void
    {
        parent::setUp();

        Factory::guessFactoryNamesUsing(
            fn (string $modelName) => 'Shawnveltman\\LaravelMinifier\\Database\\Factories\\'.class_basename($modelName).'Factory'
        );
    }

    protected function getPackageProviders($app)
    {
        return [
            LaravelMinifierServiceProvider::class,
        ];
    }

    public function getEnvironmentSetUp($app)
    {
        config()->set('database.default', 'testing');

        /*
        $migration = include __DIR__.'/../database/migrations/create_laravel-minifier_table.php.stub';
        $migration->up();
        */
    }
}
